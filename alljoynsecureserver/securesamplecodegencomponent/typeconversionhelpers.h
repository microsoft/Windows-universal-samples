//*********************************************************
//
// Copyright (c) Microsoft. All rights reserved.
// This code is licensed under the MIT License (MIT).
// THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
// IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
// PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.
//
//*********************************************************
//-----------------------------------------------------------------------------
// <auto-generated> 
//   This code was generated by a tool. 
// 
//   Changes to this file may cause incorrect behavior and will be lost if  
//   the code is regenerated.
//
//   Tool: AllJoynCodeGen.exe
//   Version: 1.0.0
//
//   This tool is located in the Windows 10 SDK and the Windows 10 AllJoyn 
//   Visual Studio Extension in the Visual Studio Extension Gallery.  
//
//   The generated code should be packaged in a Windows 10 C++/CX Runtime  
//   Component which can be consumed in any UAP-supported language using 
//   APIs that are available in Windows.Devices.AllJoyn.
//
//   Using AllJoynCodeGen - Invoke the following command with a valid 
//   Introspection XML file:
//     AllJoynCodeGen -i <INPUT XML FILE> -o <OUTPUT DIRECTORY>
// </auto-generated>
//-----------------------------------------------------------------------------
#pragma once

ref class TypeConversionHelpers
{
internal:
    // Get the array of primitive values stored in the given alljoyn_msgarg.  The values in the array will be returned as
    // a Windows::Foundation::Collections::IVector.
    template<class T>
    static _Check_return_ int32 GetPrimitiveArrayMessageArg(_In_ alljoyn_msgarg argument, _In_ PCSTR signature, _Out_ Windows::Foundation::Collections::IVector<T>^* value)
    {
        size_t elementCount = 0;
        T* arrayContents = nullptr;
        RETURN_IF_QSTATUS_ERROR(alljoyn_msgarg_get(argument, signature, &elementCount, &arrayContents));

        if (arrayContents == nullptr)
        {
            *value = ref new Platform::Collections::Vector<T>();
        }
        else
        {
            *value = ref new Platform::Collections::Vector<T>(ref new Platform::Array<T>(arrayContents, static_cast<unsigned int>(elementCount)));
        }

        return ER_OK;
    }

    // Get the array of primitive values stored in the given alljoyn_msgarg.  The values in the array will be returned as
    // a Windows::Foundation::Collections::IVectorView.
    template<class T>
    static _Check_return_ int32 GetPrimitiveArrayMessageArg(_In_ alljoyn_msgarg argument, _In_ PCSTR signature, _Out_ Windows::Foundation::Collections::IVectorView<T>^* value)
    {
        Windows::Foundation::Collections::IVector<T>^ result;
        int32 status = GetPrimitiveArrayMessageArg(argument, signature, &result);
        *value = result->GetView();
        return status;
    }

    // Check whether the value passed in is an AllJoyn type signature for an array of primitive values,
    // such as an array of int32s or an array of booleans.
    static _Check_return_ bool IsArrayOfPrimitives(_In_ PCSTR signature)
    {
        return (strlen(signature) == 2) && (signature[1] != 's') && (signature[1] != 'v');
    }

    // Find the next complete type in the given AllJoyn type signature and append it to typeSignature.
    //
    // Examples:
    //   If signature is "ii", it will append "i", because that string describes the integer type
    //   If signature is "a(is)si" it will append "a(is)", because that string fully describes an array of structures.
    static _Check_return_ int32 AppendNextCompleteType(_In_ PCSTR signature, _Out_ std::vector<char>* typeSignature);

    // Get the key and value types from the type AllJoyn type signature for a dictionary.
    static _Check_return_ int32 GetDictionaryTypeSignatures(_In_ PCSTR signature, _Out_ std::vector<char>* keySignature, _Out_ std::vector<char>* valueSignature);

    // Get the value of an alljoyn_msgarg whose value matches WinRT type T.
    //
    // The default implementation of this function passes the value directly to alljoyn_msgarg_get, which
    // will work for any primitive types (int32, byte, etc.)  More complex types that require additional
    // work to convert between the WinRT type and the AllJoyn type must have a specialization of this template
    // function to perform the conversion.
    template<class T>
    static _Check_return_ int32 GetAllJoynMessageArg(alljoyn_msgarg argument, PCSTR signature, _Out_ T* value)
    {
        return alljoyn_msgarg_get(argument, signature, value);
    }

    // Set the value of an alljoyn_msgarg to the value of WinRT type T.
    //
    // The default implementation of this function passes the value directly to alljoyn_msgarg_set, which
    // will work for any primitive types (int32, byte, etc.)  More complex types that require additional
    // work to convert between the WinRT type and the AllJoyn type must have a specialization of this template
    // function to perform the conversion.
    template<class T>
    static _Check_return_ int32 SetAllJoynMessageArg(_In_ alljoyn_msgarg argument, _In_ PCSTR signature, _In_ T value)
    {
        return alljoyn_msgarg_set(argument, signature, value);
    }

    static _Check_return_ int32 GetAllJoynMessageArg(_In_ alljoyn_msgarg argument, _In_ PCSTR signature, _Out_ Platform::String^* value)
    {
        PSTR allJoynValue;
        QStatus status = alljoyn_msgarg_get(argument, signature, &allJoynValue);
        *value = AllJoynHelpers::MultibyteToPlatformString(allJoynValue);
        return static_cast<int32>(status);
    }

    static _Check_return_ int32 SetAllJoynMessageArg(_In_ alljoyn_msgarg argument, _In_ PCSTR signature, _In_ Platform::String^ value)
    {
        std::vector<char> inputArg = AllJoynHelpers::PlatformToMultibyteString(value);
        return alljoyn_msgarg_set_and_stabilize(argument, signature, inputArg.data());
    }

    template<class T>
    static _Check_return_ int32 GetAllJoynMessageArg(_In_ alljoyn_msgarg argument, _In_ PCSTR signature, _Out_ Windows::Foundation::Collections::IVector<T>^* value)
    {
        *value = ref new Platform::Collections::Vector<T>();
        if (signature[0] != 'a')
        {
            return ER_BUS_BAD_SIGNATURE;
        }

        if (IsArrayOfPrimitives(signature))
        {
            return GetPrimitiveArrayMessageArg(argument, signature, value);
        }

        // Remove the 'a' to get the signature of an array element.
        PCSTR elementSignature = signature + 1;
        size_t elementCount = 0;
        alljoyn_msgarg arrayContents = nullptr;
        RETURN_IF_QSTATUS_ERROR(alljoyn_msgarg_get(argument, signature, &elementCount, &arrayContents));

        if (arrayContents != nullptr)
        {
            for (size_t i = 0; i < elementCount; i++)
            {
                T elementValue;
                RETURN_IF_QSTATUS_ERROR(GetAllJoynMessageArg(alljoyn_msgarg_array_element(arrayContents, i), elementSignature, &elementValue));
                (*value)->Append(elementValue);
            }
        }

        return ER_OK;
    }

    template<class T>
    static _Check_return_ int32 SetAllJoynMessageArg(_In_ alljoyn_msgarg argument, _In_ PCSTR signature, _In_ Windows::Foundation::Collections::IVectorView<T>^ value)
    {
        if (signature[0] != 'a')
        {
            return ER_BUS_BAD_SIGNATURE;
        }

        // Remove the 'a' to get the signature of an array element.
        PCSTR elementSignature = signature + 1;
        alljoyn_msgarg arrayArgument = alljoyn_msgarg_array_create(value->Size);

        for (size_t i = 0; i < value->Size; i++)
        {
            RETURN_IF_QSTATUS_ERROR(SetAllJoynMessageArg(alljoyn_msgarg_array_element(arrayArgument, i), elementSignature, value->GetAt(static_cast<unsigned int>(i))));
        }

        QStatus status = alljoyn_msgarg_set_and_stabilize(argument, "a*", (size_t)value->Size, arrayArgument);
        alljoyn_msgarg_destroy(arrayArgument);
        return static_cast<int32>(status);
    }

    template<class T>
    static _Check_return_ int32 GetAllJoynMessageArg(_In_ alljoyn_msgarg argument, _In_ PCSTR signature, _Out_ Windows::Foundation::Collections::IVectorView<T>^* value)
    {
        Windows::Foundation::Collections::IVector<T>^ result;
        int32 status = GetAllJoynMessageArg(argument, signature, &result);
        *value = result->GetView();
        return status;
    }

    template<class T>
    static _Check_return_ int32 SetAllJoynMessageArg(_In_ alljoyn_msgarg argument, _In_ PCSTR signature, _In_ Windows::Foundation::Collections::IVector<T>^ value)
    {
        return SetAllJoynMessageArg(argument, signature, value->GetView());
    }

    static _Check_return_ int32 SetAllJoynMessageArg(_In_ alljoyn_msgarg argument, _In_ PCSTR signature, _In_ Windows::Foundation::Collections::IVectorView<Platform::String^>^ value)
    {
        std::vector<std::vector<char>> strings;
        for (unsigned int i = 0; i < value->Size; i++)
        {
            strings.push_back(AllJoynHelpers::PlatformToMultibyteString(value->GetAt(i)));
        }

        // alljoyn_msgarg_set expects the strings to be in the form of an array of char*.
        std::vector<char*> allJoynArgument;
        for (unsigned int i = 0; i < value->Size; i++)
        {
            allJoynArgument.push_back(strings.at(i).data());
        }

        return alljoyn_msgarg_set_and_stabilize(argument, signature, value->Size, allJoynArgument.data());
    }

    static _Check_return_ int32 GetAllJoynMessageArg(_In_ alljoyn_msgarg argument, _In_ PCSTR signature, _Out_ Windows::Foundation::Collections::IVector<Platform::String^>^* value)
    {
        *value = ref new Platform::Collections::Vector<Platform::String^>();
        size_t elementCount = 0;
        alljoyn_msgarg arrayContents = nullptr;
        RETURN_IF_QSTATUS_ERROR(alljoyn_msgarg_get(argument, signature, &elementCount, &arrayContents));

        if (arrayContents != nullptr)
        {
            for (size_t i = 0; i < elementCount; i++)
            {
                Platform::String^ elementValue;
                RETURN_IF_QSTATUS_ERROR(GetAllJoynMessageArg(alljoyn_msgarg_array_element(arrayContents, i), "s", &elementValue));
                (*value)->Append(elementValue);
            }
        }

        return S_OK;
    }

    static _Check_return_ int32 GetAllJoynMessageArg(_In_ alljoyn_msgarg argument, _In_ PCSTR signature, _Out_ Windows::Foundation::Collections::IVectorView<Platform::String^>^* value)
    {
        Windows::Foundation::Collections::IVector<Platform::String^>^ result;
        int32 status = GetAllJoynMessageArg(argument, signature, &result);
        *value = result->GetView();
        return status;
    }

    static _Check_return_ int32 SetAllJoynMessageArg(_In_ alljoyn_msgarg argument, _In_ PCSTR signature, _In_ Windows::Foundation::Collections::IVector<Platform::String^>^ value)
    {
        return SetAllJoynMessageArg(argument, signature, value->GetView());
    }

    template<class T, class U>
    static _Check_return_ int32 GetAllJoynMessageArg(_In_ alljoyn_msgarg argument, _In_ PCSTR signature, _Out_ Windows::Foundation::Collections::IMap<T, U>^* value)
    {
        std::vector<char> keyType;
        std::vector<char> valueType;
        RETURN_IF_QSTATUS_ERROR(GetDictionaryTypeSignatures(signature, &keyType, &valueType));

        *value = ref new Platform::Collections::Map<T, U>();

        size_t elementCount = 0;
        alljoyn_msgarg dictionaryContents = nullptr;
        RETURN_IF_QSTATUS_ERROR(alljoyn_msgarg_get(argument, signature, &elementCount, &dictionaryContents));

        if (dictionaryContents != nullptr)
        {
            for (size_t i = 0; i < elementCount; i++)
            {
                alljoyn_msgarg keyArg, valueArg;
                RETURN_IF_QSTATUS_ERROR(alljoyn_msgarg_get(alljoyn_msgarg_array_element(dictionaryContents, i), "{**}", &keyArg, &valueArg));
                T dictionaryKey;
                RETURN_IF_QSTATUS_ERROR(GetAllJoynMessageArg(keyArg, keyType.data(), &dictionaryKey));
                U dictionaryValue;
                RETURN_IF_QSTATUS_ERROR(GetAllJoynMessageArg(valueArg, valueType.data(), &dictionaryValue));

                (*value)->Insert(dictionaryKey, dictionaryValue);
            }
        }

        return ER_OK;
    }

    template<class T, class U>
    static _Check_return_ int32 SetAllJoynMessageArg(_In_ alljoyn_msgarg argument, _In_ PCSTR signature, Windows::Foundation::Collections::IMapView<T, U>^ value)
    {
        std::vector<char> keyType;
        std::vector<char> valueType;
        RETURN_IF_QSTATUS_ERROR(GetDictionaryTypeSignatures(signature, &keyType, &valueType));

        alljoyn_msgarg dictionaryArg = alljoyn_msgarg_array_create(value->Size);

        int i = 0;
        for (auto dictionaryElement : value)
        {
            alljoyn_msgarg keyArg = alljoyn_msgarg_create();
            alljoyn_msgarg valueArg = alljoyn_msgarg_create();
            RETURN_IF_QSTATUS_ERROR(SetAllJoynMessageArg(keyArg, keyType.data(), dictionaryElement->Key));
            RETURN_IF_QSTATUS_ERROR(SetAllJoynMessageArg(valueArg, valueType.data(), dictionaryElement->Value));

            RETURN_IF_QSTATUS_ERROR(alljoyn_msgarg_set_and_stabilize(alljoyn_msgarg_array_element(dictionaryArg, i++), "{**}", keyArg, valueArg));
            alljoyn_msgarg_destroy(keyArg);
            alljoyn_msgarg_destroy(valueArg);
        }

        QStatus status = alljoyn_msgarg_set_and_stabilize(argument, signature, (size_t)value->Size, dictionaryArg);
        alljoyn_msgarg_destroy(dictionaryArg);
        return static_cast<int32>(status);
    }

    template<class T, class U>
    static _Check_return_ int32 GetAllJoynMessageArg(_In_ alljoyn_msgarg argument, _In_ PCSTR signature, _Out_ Windows::Foundation::Collections::IMapView<T, U>^* value)
    {
        Windows::Foundation::Collections::IMap<T, U>^ result;
        int32 status = GetAllJoynMessageArg(argument, signature, &result);
        *value = result->GetView();
        return status;
    }

    template<class T, class U>
    static _Check_return_ int32 SetAllJoynMessageArg(_In_ alljoyn_msgarg argument, _In_ PCSTR signature, _In_ Windows::Foundation::Collections::IMap<T, U>^ value)
    {
        return SetAllJoynMessageArg(argument, signature, value->GetView());
    }

    template<class T>
    static _Check_return_ int32 SetVariantArg(_In_ alljoyn_msgarg argument, _In_ PCSTR signature, _In_ T value)
    {
        alljoyn_msgarg variantArg = alljoyn_msgarg_create();
        RETURN_IF_QSTATUS_ERROR(SetAllJoynMessageArg(variantArg, signature, value));
        QStatus status = alljoyn_msgarg_set_and_stabilize(argument, "v", variantArg);
        alljoyn_msgarg_destroy(variantArg);
        return status;
    }

    template<class T>
    static _Check_return_ int32 GetVariantArg(_In_ alljoyn_msgarg argument, _In_ PCSTR signature, _In_ Platform::Object^* value)
    {
        T innerValue;
        RETURN_IF_QSTATUS_ERROR(GetAllJoynMessageArg(argument, signature, &innerValue));
        *value = innerValue;
        return ER_OK;
    }

    static _Check_return_ int32 GetMapFromVariant(_In_ alljoyn_msgarg argument, _In_ char mapSignature, _Out_ Platform::Object^* value)
    {
        switch (mapSignature)
        {
        case 'y':
        {
            return GetVariantArg<Windows::Foundation::Collections::IMap<byte, Platform::Object^>^>(argument, "a{yv}", value);
        }
        case 'b':
        {
            return GetVariantArg<Windows::Foundation::Collections::IMap<bool, Platform::Object^>^>(argument, "a{bv}", value);
        }
        case 'n':
        {
            return GetVariantArg<Windows::Foundation::Collections::IMap<int16, Platform::Object^>^>(argument, "a{nv}", value);
        }
        case 'q':
        {
            return GetVariantArg<Windows::Foundation::Collections::IMap<uint16, Platform::Object^>^>(argument, "a{qv}", value);
        }
        case 'i':
        {
            return GetVariantArg<Windows::Foundation::Collections::IMap<int32, Platform::Object^>^>(argument, "a{iv}", value);
        }
        case 'u':
        {
            return GetVariantArg<Windows::Foundation::Collections::IMap<uint32, Platform::Object^>^>(argument, "a{uv}", value);
        }
        case 'x':
        {
            return GetVariantArg<Windows::Foundation::Collections::IMap<int64, Platform::Object^>^>(argument, "a{xv}", value);
        }
        case 't':
        {
            return GetVariantArg<Windows::Foundation::Collections::IMap<uint64, Platform::Object^>^>(argument, "a{tv}", value);
        }
        case 'd':
        {
            return GetVariantArg<Windows::Foundation::Collections::IMap<double, Platform::Object^>^>(argument, "a{dv}", value);
        }
        case 's':
        {
            return GetVariantArg<Windows::Foundation::Collections::IMap<Platform::String^, Platform::Object^>^>(argument, "a{sv}", value);
        }
        default:
            return ER_BUS_BAD_SIGNATURE;
        }
    }
};